1. **Цели и ограничения**
  - **Основные функциональные требования**
    - Возможность добавлять / удалять проект
    - Возможность задавть цвет и название проекта
    - Возможность сделать задачу выполненной
    - Возможность скрывать выполненные задачи
    - Возможность удалить все выполненные задачи
    - Возможность совершать поиск по имени задачи
    - Приложение должно отображать задачи по приоритетности
    - Возможность добавлять / удалять / редактировать задачу
    - Возможность отменять действие удаления задачи
    - Возможность задать название/описание/приоритетность/категорию/время начала/время конца/день задачи
    - Возможность видеть задачи только на сегодня в виде списка и виде календаря с отображением в зависимости от времени
    - Возможность видеть задачи только на последующие дни в виде списка
  - **Основные не функциональные требования**
    - Приложение должно быстро реагировать на действия пользователей.
    - Приложение должно поддерживаться как можно большим количеством устройств Android
  - **Архитектурные цели**
    - Возможность легко расширять список атрибтов задач / категорий.
    - Возможность видеть изменения в задачах / категориях в реальном времени (то есть мы что-то изменили и это сразу отрисовалось)
    - Реализовать паттерн seperation of concerns и dependency injection
    - Реализовать паттерн one activity with multiple fragments
    - Реализовать архитектуру MVVM
    - Реализовать сохранение данных в локальной базе данных SQL
    - Реализовать сохранения состояния при убийстве приложения или ухода в background.
  - **Дополнительные цели, ограничения и предпочтения**
    - Тенденция к высокой совместимости текущей Android-реализации и возможной iOS-реализации в будущем.
    - Основной язык программирования - Kotlin. Освоить Kotlin Flows & Coroutines
2. **Описание решения**
В соответствии с нашими целями, мы получили следующее описание решения:
  - **Модули и подсистемы**
    - **UI модуль.**
Отвечает за отрисовку всех данных. Должен содержать в себе только логику, которая зависит от
элементов интерфейса (Вьюшек). Все данные для отрисовки получает из ViewModel
посредством паттерна наблюдателя. То есть мы подписываемся на какую-то переменную типа
LiveData из ViewModel и как бы “слушаем её изменения”. Как только данные изменились мы их
перерисовываем.
    - **ViewModel** Отвечает за подготовку и получения всех данных, относящихся к определенному фрагменту, а
также за сохранения данных при убийстве приложения или перехода в background. Здесь у нас
происходят вызовы функций dao для получения данных из бд. Также данный модель содержит в
себя модификацию данных. Все вызовы к бд происходят многопоточно, тем самым не блокируя
UI thread.
    - **DataBase** Отвечает за хранение данных в локальной базе данных. Представляет интерфейс методов
получения данных по запросам из бд.
    - **Hilt** Отвечает за реализацию паттерна dependency Injection
    
